// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/google/uuid"
	db "github.com/milhamh95/simplebank/db/sqlc"
)

type FakeStore struct {
	AddAccountBalanceStub        func(context.Context, db.AddAccountBalanceParams) (db.Account, error)
	addAccountBalanceMutex       sync.RWMutex
	addAccountBalanceArgsForCall []struct {
		arg1 context.Context
		arg2 db.AddAccountBalanceParams
	}
	addAccountBalanceReturns struct {
		result1 db.Account
		result2 error
	}
	addAccountBalanceReturnsOnCall map[int]struct {
		result1 db.Account
		result2 error
	}
	CreateAccountStub        func(context.Context, db.CreateAccountParams) (db.Account, error)
	createAccountMutex       sync.RWMutex
	createAccountArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateAccountParams
	}
	createAccountReturns struct {
		result1 db.Account
		result2 error
	}
	createAccountReturnsOnCall map[int]struct {
		result1 db.Account
		result2 error
	}
	CreateEntryStub        func(context.Context, db.CreateEntryParams) (db.Entry, error)
	createEntryMutex       sync.RWMutex
	createEntryArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateEntryParams
	}
	createEntryReturns struct {
		result1 db.Entry
		result2 error
	}
	createEntryReturnsOnCall map[int]struct {
		result1 db.Entry
		result2 error
	}
	CreateSessionStub        func(context.Context, db.CreateSessionParams) (db.Session, error)
	createSessionMutex       sync.RWMutex
	createSessionArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateSessionParams
	}
	createSessionReturns struct {
		result1 db.Session
		result2 error
	}
	createSessionReturnsOnCall map[int]struct {
		result1 db.Session
		result2 error
	}
	CreateTransferStub        func(context.Context, db.CreateTransferParams) (db.Transfer, error)
	createTransferMutex       sync.RWMutex
	createTransferArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateTransferParams
	}
	createTransferReturns struct {
		result1 db.Transfer
		result2 error
	}
	createTransferReturnsOnCall map[int]struct {
		result1 db.Transfer
		result2 error
	}
	CreateUserStub        func(context.Context, db.CreateUserParams) (db.User, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateUserParams
	}
	createUserReturns struct {
		result1 db.User
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 db.User
		result2 error
	}
	CreateUserTrxStub        func(context.Context, db.CreateUserTxParams) (db.CreateUserTxResult, error)
	createUserTrxMutex       sync.RWMutex
	createUserTrxArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateUserTxParams
	}
	createUserTrxReturns struct {
		result1 db.CreateUserTxResult
		result2 error
	}
	createUserTrxReturnsOnCall map[int]struct {
		result1 db.CreateUserTxResult
		result2 error
	}
	CreateVerifyEmailStub        func(context.Context, db.CreateVerifyEmailParams) (db.VerifyEmail, error)
	createVerifyEmailMutex       sync.RWMutex
	createVerifyEmailArgsForCall []struct {
		arg1 context.Context
		arg2 db.CreateVerifyEmailParams
	}
	createVerifyEmailReturns struct {
		result1 db.VerifyEmail
		result2 error
	}
	createVerifyEmailReturnsOnCall map[int]struct {
		result1 db.VerifyEmail
		result2 error
	}
	DeleteAccountStub        func(context.Context, int64) error
	deleteAccountMutex       sync.RWMutex
	deleteAccountArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	deleteAccountReturns struct {
		result1 error
	}
	deleteAccountReturnsOnCall map[int]struct {
		result1 error
	}
	GetAccountStub        func(context.Context, int64) (db.Account, error)
	getAccountMutex       sync.RWMutex
	getAccountArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getAccountReturns struct {
		result1 db.Account
		result2 error
	}
	getAccountReturnsOnCall map[int]struct {
		result1 db.Account
		result2 error
	}
	GetAccountForUpdateStub        func(context.Context, int64) (db.Account, error)
	getAccountForUpdateMutex       sync.RWMutex
	getAccountForUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getAccountForUpdateReturns struct {
		result1 db.Account
		result2 error
	}
	getAccountForUpdateReturnsOnCall map[int]struct {
		result1 db.Account
		result2 error
	}
	GetEntryStub        func(context.Context, int64) (db.Entry, error)
	getEntryMutex       sync.RWMutex
	getEntryArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getEntryReturns struct {
		result1 db.Entry
		result2 error
	}
	getEntryReturnsOnCall map[int]struct {
		result1 db.Entry
		result2 error
	}
	GetSessionStub        func(context.Context, uuid.UUID) (db.Session, error)
	getSessionMutex       sync.RWMutex
	getSessionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getSessionReturns struct {
		result1 db.Session
		result2 error
	}
	getSessionReturnsOnCall map[int]struct {
		result1 db.Session
		result2 error
	}
	GetTransferStub        func(context.Context, int64) (db.Transfer, error)
	getTransferMutex       sync.RWMutex
	getTransferArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getTransferReturns struct {
		result1 db.Transfer
		result2 error
	}
	getTransferReturnsOnCall map[int]struct {
		result1 db.Transfer
		result2 error
	}
	GetUserStub        func(context.Context, string) (db.User, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserReturns struct {
		result1 db.User
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 db.User
		result2 error
	}
	ListAccountsStub        func(context.Context, db.ListAccountsParams) ([]db.Account, error)
	listAccountsMutex       sync.RWMutex
	listAccountsArgsForCall []struct {
		arg1 context.Context
		arg2 db.ListAccountsParams
	}
	listAccountsReturns struct {
		result1 []db.Account
		result2 error
	}
	listAccountsReturnsOnCall map[int]struct {
		result1 []db.Account
		result2 error
	}
	ListEntriesStub        func(context.Context, db.ListEntriesParams) ([]db.Entry, error)
	listEntriesMutex       sync.RWMutex
	listEntriesArgsForCall []struct {
		arg1 context.Context
		arg2 db.ListEntriesParams
	}
	listEntriesReturns struct {
		result1 []db.Entry
		result2 error
	}
	listEntriesReturnsOnCall map[int]struct {
		result1 []db.Entry
		result2 error
	}
	ListTransfersStub        func(context.Context, db.ListTransfersParams) ([]db.Transfer, error)
	listTransfersMutex       sync.RWMutex
	listTransfersArgsForCall []struct {
		arg1 context.Context
		arg2 db.ListTransfersParams
	}
	listTransfersReturns struct {
		result1 []db.Transfer
		result2 error
	}
	listTransfersReturnsOnCall map[int]struct {
		result1 []db.Transfer
		result2 error
	}
	TransferTrxStub        func(context.Context, db.TransferTxParams) (db.TransferTxResult, error)
	transferTrxMutex       sync.RWMutex
	transferTrxArgsForCall []struct {
		arg1 context.Context
		arg2 db.TransferTxParams
	}
	transferTrxReturns struct {
		result1 db.TransferTxResult
		result2 error
	}
	transferTrxReturnsOnCall map[int]struct {
		result1 db.TransferTxResult
		result2 error
	}
	UpdateAccountStub        func(context.Context, db.UpdateAccountParams) (db.Account, error)
	updateAccountMutex       sync.RWMutex
	updateAccountArgsForCall []struct {
		arg1 context.Context
		arg2 db.UpdateAccountParams
	}
	updateAccountReturns struct {
		result1 db.Account
		result2 error
	}
	updateAccountReturnsOnCall map[int]struct {
		result1 db.Account
		result2 error
	}
	UpdateUserStub        func(context.Context, db.UpdateUserParams) (db.User, error)
	updateUserMutex       sync.RWMutex
	updateUserArgsForCall []struct {
		arg1 context.Context
		arg2 db.UpdateUserParams
	}
	updateUserReturns struct {
		result1 db.User
		result2 error
	}
	updateUserReturnsOnCall map[int]struct {
		result1 db.User
		result2 error
	}
	UpdateVerifyEmailStub        func(context.Context, db.UpdateVerifyEmailParams) (db.VerifyEmail, error)
	updateVerifyEmailMutex       sync.RWMutex
	updateVerifyEmailArgsForCall []struct {
		arg1 context.Context
		arg2 db.UpdateVerifyEmailParams
	}
	updateVerifyEmailReturns struct {
		result1 db.VerifyEmail
		result2 error
	}
	updateVerifyEmailReturnsOnCall map[int]struct {
		result1 db.VerifyEmail
		result2 error
	}
	VerifyEmailTxStub        func(context.Context, db.VerifyEmailTxParams) (db.VerifyEmailTxResult, error)
	verifyEmailTxMutex       sync.RWMutex
	verifyEmailTxArgsForCall []struct {
		arg1 context.Context
		arg2 db.VerifyEmailTxParams
	}
	verifyEmailTxReturns struct {
		result1 db.VerifyEmailTxResult
		result2 error
	}
	verifyEmailTxReturnsOnCall map[int]struct {
		result1 db.VerifyEmailTxResult
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStore) AddAccountBalance(arg1 context.Context, arg2 db.AddAccountBalanceParams) (db.Account, error) {
	fake.addAccountBalanceMutex.Lock()
	ret, specificReturn := fake.addAccountBalanceReturnsOnCall[len(fake.addAccountBalanceArgsForCall)]
	fake.addAccountBalanceArgsForCall = append(fake.addAccountBalanceArgsForCall, struct {
		arg1 context.Context
		arg2 db.AddAccountBalanceParams
	}{arg1, arg2})
	stub := fake.AddAccountBalanceStub
	fakeReturns := fake.addAccountBalanceReturns
	fake.recordInvocation("AddAccountBalance", []interface{}{arg1, arg2})
	fake.addAccountBalanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) AddAccountBalanceCallCount() int {
	fake.addAccountBalanceMutex.RLock()
	defer fake.addAccountBalanceMutex.RUnlock()
	return len(fake.addAccountBalanceArgsForCall)
}

func (fake *FakeStore) AddAccountBalanceCalls(stub func(context.Context, db.AddAccountBalanceParams) (db.Account, error)) {
	fake.addAccountBalanceMutex.Lock()
	defer fake.addAccountBalanceMutex.Unlock()
	fake.AddAccountBalanceStub = stub
}

func (fake *FakeStore) AddAccountBalanceArgsForCall(i int) (context.Context, db.AddAccountBalanceParams) {
	fake.addAccountBalanceMutex.RLock()
	defer fake.addAccountBalanceMutex.RUnlock()
	argsForCall := fake.addAccountBalanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) AddAccountBalanceReturns(result1 db.Account, result2 error) {
	fake.addAccountBalanceMutex.Lock()
	defer fake.addAccountBalanceMutex.Unlock()
	fake.AddAccountBalanceStub = nil
	fake.addAccountBalanceReturns = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) AddAccountBalanceReturnsOnCall(i int, result1 db.Account, result2 error) {
	fake.addAccountBalanceMutex.Lock()
	defer fake.addAccountBalanceMutex.Unlock()
	fake.AddAccountBalanceStub = nil
	if fake.addAccountBalanceReturnsOnCall == nil {
		fake.addAccountBalanceReturnsOnCall = make(map[int]struct {
			result1 db.Account
			result2 error
		})
	}
	fake.addAccountBalanceReturnsOnCall[i] = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateAccount(arg1 context.Context, arg2 db.CreateAccountParams) (db.Account, error) {
	fake.createAccountMutex.Lock()
	ret, specificReturn := fake.createAccountReturnsOnCall[len(fake.createAccountArgsForCall)]
	fake.createAccountArgsForCall = append(fake.createAccountArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateAccountParams
	}{arg1, arg2})
	stub := fake.CreateAccountStub
	fakeReturns := fake.createAccountReturns
	fake.recordInvocation("CreateAccount", []interface{}{arg1, arg2})
	fake.createAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateAccountCallCount() int {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	return len(fake.createAccountArgsForCall)
}

func (fake *FakeStore) CreateAccountCalls(stub func(context.Context, db.CreateAccountParams) (db.Account, error)) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = stub
}

func (fake *FakeStore) CreateAccountArgsForCall(i int) (context.Context, db.CreateAccountParams) {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	argsForCall := fake.createAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateAccountReturns(result1 db.Account, result2 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	fake.createAccountReturns = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateAccountReturnsOnCall(i int, result1 db.Account, result2 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	if fake.createAccountReturnsOnCall == nil {
		fake.createAccountReturnsOnCall = make(map[int]struct {
			result1 db.Account
			result2 error
		})
	}
	fake.createAccountReturnsOnCall[i] = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateEntry(arg1 context.Context, arg2 db.CreateEntryParams) (db.Entry, error) {
	fake.createEntryMutex.Lock()
	ret, specificReturn := fake.createEntryReturnsOnCall[len(fake.createEntryArgsForCall)]
	fake.createEntryArgsForCall = append(fake.createEntryArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateEntryParams
	}{arg1, arg2})
	stub := fake.CreateEntryStub
	fakeReturns := fake.createEntryReturns
	fake.recordInvocation("CreateEntry", []interface{}{arg1, arg2})
	fake.createEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateEntryCallCount() int {
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	return len(fake.createEntryArgsForCall)
}

func (fake *FakeStore) CreateEntryCalls(stub func(context.Context, db.CreateEntryParams) (db.Entry, error)) {
	fake.createEntryMutex.Lock()
	defer fake.createEntryMutex.Unlock()
	fake.CreateEntryStub = stub
}

func (fake *FakeStore) CreateEntryArgsForCall(i int) (context.Context, db.CreateEntryParams) {
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	argsForCall := fake.createEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateEntryReturns(result1 db.Entry, result2 error) {
	fake.createEntryMutex.Lock()
	defer fake.createEntryMutex.Unlock()
	fake.CreateEntryStub = nil
	fake.createEntryReturns = struct {
		result1 db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateEntryReturnsOnCall(i int, result1 db.Entry, result2 error) {
	fake.createEntryMutex.Lock()
	defer fake.createEntryMutex.Unlock()
	fake.CreateEntryStub = nil
	if fake.createEntryReturnsOnCall == nil {
		fake.createEntryReturnsOnCall = make(map[int]struct {
			result1 db.Entry
			result2 error
		})
	}
	fake.createEntryReturnsOnCall[i] = struct {
		result1 db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateSession(arg1 context.Context, arg2 db.CreateSessionParams) (db.Session, error) {
	fake.createSessionMutex.Lock()
	ret, specificReturn := fake.createSessionReturnsOnCall[len(fake.createSessionArgsForCall)]
	fake.createSessionArgsForCall = append(fake.createSessionArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateSessionParams
	}{arg1, arg2})
	stub := fake.CreateSessionStub
	fakeReturns := fake.createSessionReturns
	fake.recordInvocation("CreateSession", []interface{}{arg1, arg2})
	fake.createSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateSessionCallCount() int {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	return len(fake.createSessionArgsForCall)
}

func (fake *FakeStore) CreateSessionCalls(stub func(context.Context, db.CreateSessionParams) (db.Session, error)) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = stub
}

func (fake *FakeStore) CreateSessionArgsForCall(i int) (context.Context, db.CreateSessionParams) {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	argsForCall := fake.createSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateSessionReturns(result1 db.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	fake.createSessionReturns = struct {
		result1 db.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateSessionReturnsOnCall(i int, result1 db.Session, result2 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	if fake.createSessionReturnsOnCall == nil {
		fake.createSessionReturnsOnCall = make(map[int]struct {
			result1 db.Session
			result2 error
		})
	}
	fake.createSessionReturnsOnCall[i] = struct {
		result1 db.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateTransfer(arg1 context.Context, arg2 db.CreateTransferParams) (db.Transfer, error) {
	fake.createTransferMutex.Lock()
	ret, specificReturn := fake.createTransferReturnsOnCall[len(fake.createTransferArgsForCall)]
	fake.createTransferArgsForCall = append(fake.createTransferArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateTransferParams
	}{arg1, arg2})
	stub := fake.CreateTransferStub
	fakeReturns := fake.createTransferReturns
	fake.recordInvocation("CreateTransfer", []interface{}{arg1, arg2})
	fake.createTransferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateTransferCallCount() int {
	fake.createTransferMutex.RLock()
	defer fake.createTransferMutex.RUnlock()
	return len(fake.createTransferArgsForCall)
}

func (fake *FakeStore) CreateTransferCalls(stub func(context.Context, db.CreateTransferParams) (db.Transfer, error)) {
	fake.createTransferMutex.Lock()
	defer fake.createTransferMutex.Unlock()
	fake.CreateTransferStub = stub
}

func (fake *FakeStore) CreateTransferArgsForCall(i int) (context.Context, db.CreateTransferParams) {
	fake.createTransferMutex.RLock()
	defer fake.createTransferMutex.RUnlock()
	argsForCall := fake.createTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateTransferReturns(result1 db.Transfer, result2 error) {
	fake.createTransferMutex.Lock()
	defer fake.createTransferMutex.Unlock()
	fake.CreateTransferStub = nil
	fake.createTransferReturns = struct {
		result1 db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateTransferReturnsOnCall(i int, result1 db.Transfer, result2 error) {
	fake.createTransferMutex.Lock()
	defer fake.createTransferMutex.Unlock()
	fake.CreateTransferStub = nil
	if fake.createTransferReturnsOnCall == nil {
		fake.createTransferReturnsOnCall = make(map[int]struct {
			result1 db.Transfer
			result2 error
		})
	}
	fake.createTransferReturnsOnCall[i] = struct {
		result1 db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateUser(arg1 context.Context, arg2 db.CreateUserParams) (db.User, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateUserParams
	}{arg1, arg2})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeStore) CreateUserCalls(stub func(context.Context, db.CreateUserParams) (db.User, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeStore) CreateUserArgsForCall(i int) (context.Context, db.CreateUserParams) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateUserReturns(result1 db.User, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateUserReturnsOnCall(i int, result1 db.User, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 db.User
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateUserTrx(arg1 context.Context, arg2 db.CreateUserTxParams) (db.CreateUserTxResult, error) {
	fake.createUserTrxMutex.Lock()
	ret, specificReturn := fake.createUserTrxReturnsOnCall[len(fake.createUserTrxArgsForCall)]
	fake.createUserTrxArgsForCall = append(fake.createUserTrxArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateUserTxParams
	}{arg1, arg2})
	stub := fake.CreateUserTrxStub
	fakeReturns := fake.createUserTrxReturns
	fake.recordInvocation("CreateUserTrx", []interface{}{arg1, arg2})
	fake.createUserTrxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateUserTrxCallCount() int {
	fake.createUserTrxMutex.RLock()
	defer fake.createUserTrxMutex.RUnlock()
	return len(fake.createUserTrxArgsForCall)
}

func (fake *FakeStore) CreateUserTrxCalls(stub func(context.Context, db.CreateUserTxParams) (db.CreateUserTxResult, error)) {
	fake.createUserTrxMutex.Lock()
	defer fake.createUserTrxMutex.Unlock()
	fake.CreateUserTrxStub = stub
}

func (fake *FakeStore) CreateUserTrxArgsForCall(i int) (context.Context, db.CreateUserTxParams) {
	fake.createUserTrxMutex.RLock()
	defer fake.createUserTrxMutex.RUnlock()
	argsForCall := fake.createUserTrxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateUserTrxReturns(result1 db.CreateUserTxResult, result2 error) {
	fake.createUserTrxMutex.Lock()
	defer fake.createUserTrxMutex.Unlock()
	fake.CreateUserTrxStub = nil
	fake.createUserTrxReturns = struct {
		result1 db.CreateUserTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateUserTrxReturnsOnCall(i int, result1 db.CreateUserTxResult, result2 error) {
	fake.createUserTrxMutex.Lock()
	defer fake.createUserTrxMutex.Unlock()
	fake.CreateUserTrxStub = nil
	if fake.createUserTrxReturnsOnCall == nil {
		fake.createUserTrxReturnsOnCall = make(map[int]struct {
			result1 db.CreateUserTxResult
			result2 error
		})
	}
	fake.createUserTrxReturnsOnCall[i] = struct {
		result1 db.CreateUserTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateVerifyEmail(arg1 context.Context, arg2 db.CreateVerifyEmailParams) (db.VerifyEmail, error) {
	fake.createVerifyEmailMutex.Lock()
	ret, specificReturn := fake.createVerifyEmailReturnsOnCall[len(fake.createVerifyEmailArgsForCall)]
	fake.createVerifyEmailArgsForCall = append(fake.createVerifyEmailArgsForCall, struct {
		arg1 context.Context
		arg2 db.CreateVerifyEmailParams
	}{arg1, arg2})
	stub := fake.CreateVerifyEmailStub
	fakeReturns := fake.createVerifyEmailReturns
	fake.recordInvocation("CreateVerifyEmail", []interface{}{arg1, arg2})
	fake.createVerifyEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateVerifyEmailCallCount() int {
	fake.createVerifyEmailMutex.RLock()
	defer fake.createVerifyEmailMutex.RUnlock()
	return len(fake.createVerifyEmailArgsForCall)
}

func (fake *FakeStore) CreateVerifyEmailCalls(stub func(context.Context, db.CreateVerifyEmailParams) (db.VerifyEmail, error)) {
	fake.createVerifyEmailMutex.Lock()
	defer fake.createVerifyEmailMutex.Unlock()
	fake.CreateVerifyEmailStub = stub
}

func (fake *FakeStore) CreateVerifyEmailArgsForCall(i int) (context.Context, db.CreateVerifyEmailParams) {
	fake.createVerifyEmailMutex.RLock()
	defer fake.createVerifyEmailMutex.RUnlock()
	argsForCall := fake.createVerifyEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) CreateVerifyEmailReturns(result1 db.VerifyEmail, result2 error) {
	fake.createVerifyEmailMutex.Lock()
	defer fake.createVerifyEmailMutex.Unlock()
	fake.CreateVerifyEmailStub = nil
	fake.createVerifyEmailReturns = struct {
		result1 db.VerifyEmail
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateVerifyEmailReturnsOnCall(i int, result1 db.VerifyEmail, result2 error) {
	fake.createVerifyEmailMutex.Lock()
	defer fake.createVerifyEmailMutex.Unlock()
	fake.CreateVerifyEmailStub = nil
	if fake.createVerifyEmailReturnsOnCall == nil {
		fake.createVerifyEmailReturnsOnCall = make(map[int]struct {
			result1 db.VerifyEmail
			result2 error
		})
	}
	fake.createVerifyEmailReturnsOnCall[i] = struct {
		result1 db.VerifyEmail
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) DeleteAccount(arg1 context.Context, arg2 int64) error {
	fake.deleteAccountMutex.Lock()
	ret, specificReturn := fake.deleteAccountReturnsOnCall[len(fake.deleteAccountArgsForCall)]
	fake.deleteAccountArgsForCall = append(fake.deleteAccountArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.DeleteAccountStub
	fakeReturns := fake.deleteAccountReturns
	fake.recordInvocation("DeleteAccount", []interface{}{arg1, arg2})
	fake.deleteAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStore) DeleteAccountCallCount() int {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	return len(fake.deleteAccountArgsForCall)
}

func (fake *FakeStore) DeleteAccountCalls(stub func(context.Context, int64) error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = stub
}

func (fake *FakeStore) DeleteAccountArgsForCall(i int) (context.Context, int64) {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	argsForCall := fake.deleteAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) DeleteAccountReturns(result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	fake.deleteAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) DeleteAccountReturnsOnCall(i int, result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	if fake.deleteAccountReturnsOnCall == nil {
		fake.deleteAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) GetAccount(arg1 context.Context, arg2 int64) (db.Account, error) {
	fake.getAccountMutex.Lock()
	ret, specificReturn := fake.getAccountReturnsOnCall[len(fake.getAccountArgsForCall)]
	fake.getAccountArgsForCall = append(fake.getAccountArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetAccountStub
	fakeReturns := fake.getAccountReturns
	fake.recordInvocation("GetAccount", []interface{}{arg1, arg2})
	fake.getAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetAccountCallCount() int {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	return len(fake.getAccountArgsForCall)
}

func (fake *FakeStore) GetAccountCalls(stub func(context.Context, int64) (db.Account, error)) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = stub
}

func (fake *FakeStore) GetAccountArgsForCall(i int) (context.Context, int64) {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	argsForCall := fake.getAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetAccountReturns(result1 db.Account, result2 error) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = nil
	fake.getAccountReturns = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAccountReturnsOnCall(i int, result1 db.Account, result2 error) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = nil
	if fake.getAccountReturnsOnCall == nil {
		fake.getAccountReturnsOnCall = make(map[int]struct {
			result1 db.Account
			result2 error
		})
	}
	fake.getAccountReturnsOnCall[i] = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAccountForUpdate(arg1 context.Context, arg2 int64) (db.Account, error) {
	fake.getAccountForUpdateMutex.Lock()
	ret, specificReturn := fake.getAccountForUpdateReturnsOnCall[len(fake.getAccountForUpdateArgsForCall)]
	fake.getAccountForUpdateArgsForCall = append(fake.getAccountForUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetAccountForUpdateStub
	fakeReturns := fake.getAccountForUpdateReturns
	fake.recordInvocation("GetAccountForUpdate", []interface{}{arg1, arg2})
	fake.getAccountForUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetAccountForUpdateCallCount() int {
	fake.getAccountForUpdateMutex.RLock()
	defer fake.getAccountForUpdateMutex.RUnlock()
	return len(fake.getAccountForUpdateArgsForCall)
}

func (fake *FakeStore) GetAccountForUpdateCalls(stub func(context.Context, int64) (db.Account, error)) {
	fake.getAccountForUpdateMutex.Lock()
	defer fake.getAccountForUpdateMutex.Unlock()
	fake.GetAccountForUpdateStub = stub
}

func (fake *FakeStore) GetAccountForUpdateArgsForCall(i int) (context.Context, int64) {
	fake.getAccountForUpdateMutex.RLock()
	defer fake.getAccountForUpdateMutex.RUnlock()
	argsForCall := fake.getAccountForUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetAccountForUpdateReturns(result1 db.Account, result2 error) {
	fake.getAccountForUpdateMutex.Lock()
	defer fake.getAccountForUpdateMutex.Unlock()
	fake.GetAccountForUpdateStub = nil
	fake.getAccountForUpdateReturns = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAccountForUpdateReturnsOnCall(i int, result1 db.Account, result2 error) {
	fake.getAccountForUpdateMutex.Lock()
	defer fake.getAccountForUpdateMutex.Unlock()
	fake.GetAccountForUpdateStub = nil
	if fake.getAccountForUpdateReturnsOnCall == nil {
		fake.getAccountForUpdateReturnsOnCall = make(map[int]struct {
			result1 db.Account
			result2 error
		})
	}
	fake.getAccountForUpdateReturnsOnCall[i] = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetEntry(arg1 context.Context, arg2 int64) (db.Entry, error) {
	fake.getEntryMutex.Lock()
	ret, specificReturn := fake.getEntryReturnsOnCall[len(fake.getEntryArgsForCall)]
	fake.getEntryArgsForCall = append(fake.getEntryArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetEntryStub
	fakeReturns := fake.getEntryReturns
	fake.recordInvocation("GetEntry", []interface{}{arg1, arg2})
	fake.getEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetEntryCallCount() int {
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	return len(fake.getEntryArgsForCall)
}

func (fake *FakeStore) GetEntryCalls(stub func(context.Context, int64) (db.Entry, error)) {
	fake.getEntryMutex.Lock()
	defer fake.getEntryMutex.Unlock()
	fake.GetEntryStub = stub
}

func (fake *FakeStore) GetEntryArgsForCall(i int) (context.Context, int64) {
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	argsForCall := fake.getEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetEntryReturns(result1 db.Entry, result2 error) {
	fake.getEntryMutex.Lock()
	defer fake.getEntryMutex.Unlock()
	fake.GetEntryStub = nil
	fake.getEntryReturns = struct {
		result1 db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetEntryReturnsOnCall(i int, result1 db.Entry, result2 error) {
	fake.getEntryMutex.Lock()
	defer fake.getEntryMutex.Unlock()
	fake.GetEntryStub = nil
	if fake.getEntryReturnsOnCall == nil {
		fake.getEntryReturnsOnCall = make(map[int]struct {
			result1 db.Entry
			result2 error
		})
	}
	fake.getEntryReturnsOnCall[i] = struct {
		result1 db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetSession(arg1 context.Context, arg2 uuid.UUID) (db.Session, error) {
	fake.getSessionMutex.Lock()
	ret, specificReturn := fake.getSessionReturnsOnCall[len(fake.getSessionArgsForCall)]
	fake.getSessionArgsForCall = append(fake.getSessionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetSessionStub
	fakeReturns := fake.getSessionReturns
	fake.recordInvocation("GetSession", []interface{}{arg1, arg2})
	fake.getSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetSessionCallCount() int {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	return len(fake.getSessionArgsForCall)
}

func (fake *FakeStore) GetSessionCalls(stub func(context.Context, uuid.UUID) (db.Session, error)) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = stub
}

func (fake *FakeStore) GetSessionArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	argsForCall := fake.getSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetSessionReturns(result1 db.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	fake.getSessionReturns = struct {
		result1 db.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetSessionReturnsOnCall(i int, result1 db.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	if fake.getSessionReturnsOnCall == nil {
		fake.getSessionReturnsOnCall = make(map[int]struct {
			result1 db.Session
			result2 error
		})
	}
	fake.getSessionReturnsOnCall[i] = struct {
		result1 db.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetTransfer(arg1 context.Context, arg2 int64) (db.Transfer, error) {
	fake.getTransferMutex.Lock()
	ret, specificReturn := fake.getTransferReturnsOnCall[len(fake.getTransferArgsForCall)]
	fake.getTransferArgsForCall = append(fake.getTransferArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetTransferStub
	fakeReturns := fake.getTransferReturns
	fake.recordInvocation("GetTransfer", []interface{}{arg1, arg2})
	fake.getTransferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetTransferCallCount() int {
	fake.getTransferMutex.RLock()
	defer fake.getTransferMutex.RUnlock()
	return len(fake.getTransferArgsForCall)
}

func (fake *FakeStore) GetTransferCalls(stub func(context.Context, int64) (db.Transfer, error)) {
	fake.getTransferMutex.Lock()
	defer fake.getTransferMutex.Unlock()
	fake.GetTransferStub = stub
}

func (fake *FakeStore) GetTransferArgsForCall(i int) (context.Context, int64) {
	fake.getTransferMutex.RLock()
	defer fake.getTransferMutex.RUnlock()
	argsForCall := fake.getTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetTransferReturns(result1 db.Transfer, result2 error) {
	fake.getTransferMutex.Lock()
	defer fake.getTransferMutex.Unlock()
	fake.GetTransferStub = nil
	fake.getTransferReturns = struct {
		result1 db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetTransferReturnsOnCall(i int, result1 db.Transfer, result2 error) {
	fake.getTransferMutex.Lock()
	defer fake.getTransferMutex.Unlock()
	fake.GetTransferStub = nil
	if fake.getTransferReturnsOnCall == nil {
		fake.getTransferReturnsOnCall = make(map[int]struct {
			result1 db.Transfer
			result2 error
		})
	}
	fake.getTransferReturnsOnCall[i] = struct {
		result1 db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetUser(arg1 context.Context, arg2 string) (db.User, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *FakeStore) GetUserCalls(stub func(context.Context, string) (db.User, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *FakeStore) GetUserArgsForCall(i int) (context.Context, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetUserReturns(result1 db.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetUserReturnsOnCall(i int, result1 db.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 db.User
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListAccounts(arg1 context.Context, arg2 db.ListAccountsParams) ([]db.Account, error) {
	fake.listAccountsMutex.Lock()
	ret, specificReturn := fake.listAccountsReturnsOnCall[len(fake.listAccountsArgsForCall)]
	fake.listAccountsArgsForCall = append(fake.listAccountsArgsForCall, struct {
		arg1 context.Context
		arg2 db.ListAccountsParams
	}{arg1, arg2})
	stub := fake.ListAccountsStub
	fakeReturns := fake.listAccountsReturns
	fake.recordInvocation("ListAccounts", []interface{}{arg1, arg2})
	fake.listAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) ListAccountsCallCount() int {
	fake.listAccountsMutex.RLock()
	defer fake.listAccountsMutex.RUnlock()
	return len(fake.listAccountsArgsForCall)
}

func (fake *FakeStore) ListAccountsCalls(stub func(context.Context, db.ListAccountsParams) ([]db.Account, error)) {
	fake.listAccountsMutex.Lock()
	defer fake.listAccountsMutex.Unlock()
	fake.ListAccountsStub = stub
}

func (fake *FakeStore) ListAccountsArgsForCall(i int) (context.Context, db.ListAccountsParams) {
	fake.listAccountsMutex.RLock()
	defer fake.listAccountsMutex.RUnlock()
	argsForCall := fake.listAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) ListAccountsReturns(result1 []db.Account, result2 error) {
	fake.listAccountsMutex.Lock()
	defer fake.listAccountsMutex.Unlock()
	fake.ListAccountsStub = nil
	fake.listAccountsReturns = struct {
		result1 []db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListAccountsReturnsOnCall(i int, result1 []db.Account, result2 error) {
	fake.listAccountsMutex.Lock()
	defer fake.listAccountsMutex.Unlock()
	fake.ListAccountsStub = nil
	if fake.listAccountsReturnsOnCall == nil {
		fake.listAccountsReturnsOnCall = make(map[int]struct {
			result1 []db.Account
			result2 error
		})
	}
	fake.listAccountsReturnsOnCall[i] = struct {
		result1 []db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListEntries(arg1 context.Context, arg2 db.ListEntriesParams) ([]db.Entry, error) {
	fake.listEntriesMutex.Lock()
	ret, specificReturn := fake.listEntriesReturnsOnCall[len(fake.listEntriesArgsForCall)]
	fake.listEntriesArgsForCall = append(fake.listEntriesArgsForCall, struct {
		arg1 context.Context
		arg2 db.ListEntriesParams
	}{arg1, arg2})
	stub := fake.ListEntriesStub
	fakeReturns := fake.listEntriesReturns
	fake.recordInvocation("ListEntries", []interface{}{arg1, arg2})
	fake.listEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) ListEntriesCallCount() int {
	fake.listEntriesMutex.RLock()
	defer fake.listEntriesMutex.RUnlock()
	return len(fake.listEntriesArgsForCall)
}

func (fake *FakeStore) ListEntriesCalls(stub func(context.Context, db.ListEntriesParams) ([]db.Entry, error)) {
	fake.listEntriesMutex.Lock()
	defer fake.listEntriesMutex.Unlock()
	fake.ListEntriesStub = stub
}

func (fake *FakeStore) ListEntriesArgsForCall(i int) (context.Context, db.ListEntriesParams) {
	fake.listEntriesMutex.RLock()
	defer fake.listEntriesMutex.RUnlock()
	argsForCall := fake.listEntriesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) ListEntriesReturns(result1 []db.Entry, result2 error) {
	fake.listEntriesMutex.Lock()
	defer fake.listEntriesMutex.Unlock()
	fake.ListEntriesStub = nil
	fake.listEntriesReturns = struct {
		result1 []db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListEntriesReturnsOnCall(i int, result1 []db.Entry, result2 error) {
	fake.listEntriesMutex.Lock()
	defer fake.listEntriesMutex.Unlock()
	fake.ListEntriesStub = nil
	if fake.listEntriesReturnsOnCall == nil {
		fake.listEntriesReturnsOnCall = make(map[int]struct {
			result1 []db.Entry
			result2 error
		})
	}
	fake.listEntriesReturnsOnCall[i] = struct {
		result1 []db.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListTransfers(arg1 context.Context, arg2 db.ListTransfersParams) ([]db.Transfer, error) {
	fake.listTransfersMutex.Lock()
	ret, specificReturn := fake.listTransfersReturnsOnCall[len(fake.listTransfersArgsForCall)]
	fake.listTransfersArgsForCall = append(fake.listTransfersArgsForCall, struct {
		arg1 context.Context
		arg2 db.ListTransfersParams
	}{arg1, arg2})
	stub := fake.ListTransfersStub
	fakeReturns := fake.listTransfersReturns
	fake.recordInvocation("ListTransfers", []interface{}{arg1, arg2})
	fake.listTransfersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) ListTransfersCallCount() int {
	fake.listTransfersMutex.RLock()
	defer fake.listTransfersMutex.RUnlock()
	return len(fake.listTransfersArgsForCall)
}

func (fake *FakeStore) ListTransfersCalls(stub func(context.Context, db.ListTransfersParams) ([]db.Transfer, error)) {
	fake.listTransfersMutex.Lock()
	defer fake.listTransfersMutex.Unlock()
	fake.ListTransfersStub = stub
}

func (fake *FakeStore) ListTransfersArgsForCall(i int) (context.Context, db.ListTransfersParams) {
	fake.listTransfersMutex.RLock()
	defer fake.listTransfersMutex.RUnlock()
	argsForCall := fake.listTransfersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) ListTransfersReturns(result1 []db.Transfer, result2 error) {
	fake.listTransfersMutex.Lock()
	defer fake.listTransfersMutex.Unlock()
	fake.ListTransfersStub = nil
	fake.listTransfersReturns = struct {
		result1 []db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) ListTransfersReturnsOnCall(i int, result1 []db.Transfer, result2 error) {
	fake.listTransfersMutex.Lock()
	defer fake.listTransfersMutex.Unlock()
	fake.ListTransfersStub = nil
	if fake.listTransfersReturnsOnCall == nil {
		fake.listTransfersReturnsOnCall = make(map[int]struct {
			result1 []db.Transfer
			result2 error
		})
	}
	fake.listTransfersReturnsOnCall[i] = struct {
		result1 []db.Transfer
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) TransferTrx(arg1 context.Context, arg2 db.TransferTxParams) (db.TransferTxResult, error) {
	fake.transferTrxMutex.Lock()
	ret, specificReturn := fake.transferTrxReturnsOnCall[len(fake.transferTrxArgsForCall)]
	fake.transferTrxArgsForCall = append(fake.transferTrxArgsForCall, struct {
		arg1 context.Context
		arg2 db.TransferTxParams
	}{arg1, arg2})
	stub := fake.TransferTrxStub
	fakeReturns := fake.transferTrxReturns
	fake.recordInvocation("TransferTrx", []interface{}{arg1, arg2})
	fake.transferTrxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) TransferTrxCallCount() int {
	fake.transferTrxMutex.RLock()
	defer fake.transferTrxMutex.RUnlock()
	return len(fake.transferTrxArgsForCall)
}

func (fake *FakeStore) TransferTrxCalls(stub func(context.Context, db.TransferTxParams) (db.TransferTxResult, error)) {
	fake.transferTrxMutex.Lock()
	defer fake.transferTrxMutex.Unlock()
	fake.TransferTrxStub = stub
}

func (fake *FakeStore) TransferTrxArgsForCall(i int) (context.Context, db.TransferTxParams) {
	fake.transferTrxMutex.RLock()
	defer fake.transferTrxMutex.RUnlock()
	argsForCall := fake.transferTrxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) TransferTrxReturns(result1 db.TransferTxResult, result2 error) {
	fake.transferTrxMutex.Lock()
	defer fake.transferTrxMutex.Unlock()
	fake.TransferTrxStub = nil
	fake.transferTrxReturns = struct {
		result1 db.TransferTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) TransferTrxReturnsOnCall(i int, result1 db.TransferTxResult, result2 error) {
	fake.transferTrxMutex.Lock()
	defer fake.transferTrxMutex.Unlock()
	fake.TransferTrxStub = nil
	if fake.transferTrxReturnsOnCall == nil {
		fake.transferTrxReturnsOnCall = make(map[int]struct {
			result1 db.TransferTxResult
			result2 error
		})
	}
	fake.transferTrxReturnsOnCall[i] = struct {
		result1 db.TransferTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccount(arg1 context.Context, arg2 db.UpdateAccountParams) (db.Account, error) {
	fake.updateAccountMutex.Lock()
	ret, specificReturn := fake.updateAccountReturnsOnCall[len(fake.updateAccountArgsForCall)]
	fake.updateAccountArgsForCall = append(fake.updateAccountArgsForCall, struct {
		arg1 context.Context
		arg2 db.UpdateAccountParams
	}{arg1, arg2})
	stub := fake.UpdateAccountStub
	fakeReturns := fake.updateAccountReturns
	fake.recordInvocation("UpdateAccount", []interface{}{arg1, arg2})
	fake.updateAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) UpdateAccountCallCount() int {
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	return len(fake.updateAccountArgsForCall)
}

func (fake *FakeStore) UpdateAccountCalls(stub func(context.Context, db.UpdateAccountParams) (db.Account, error)) {
	fake.updateAccountMutex.Lock()
	defer fake.updateAccountMutex.Unlock()
	fake.UpdateAccountStub = stub
}

func (fake *FakeStore) UpdateAccountArgsForCall(i int) (context.Context, db.UpdateAccountParams) {
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	argsForCall := fake.updateAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) UpdateAccountReturns(result1 db.Account, result2 error) {
	fake.updateAccountMutex.Lock()
	defer fake.updateAccountMutex.Unlock()
	fake.UpdateAccountStub = nil
	fake.updateAccountReturns = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccountReturnsOnCall(i int, result1 db.Account, result2 error) {
	fake.updateAccountMutex.Lock()
	defer fake.updateAccountMutex.Unlock()
	fake.UpdateAccountStub = nil
	if fake.updateAccountReturnsOnCall == nil {
		fake.updateAccountReturnsOnCall = make(map[int]struct {
			result1 db.Account
			result2 error
		})
	}
	fake.updateAccountReturnsOnCall[i] = struct {
		result1 db.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateUser(arg1 context.Context, arg2 db.UpdateUserParams) (db.User, error) {
	fake.updateUserMutex.Lock()
	ret, specificReturn := fake.updateUserReturnsOnCall[len(fake.updateUserArgsForCall)]
	fake.updateUserArgsForCall = append(fake.updateUserArgsForCall, struct {
		arg1 context.Context
		arg2 db.UpdateUserParams
	}{arg1, arg2})
	stub := fake.UpdateUserStub
	fakeReturns := fake.updateUserReturns
	fake.recordInvocation("UpdateUser", []interface{}{arg1, arg2})
	fake.updateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) UpdateUserCallCount() int {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	return len(fake.updateUserArgsForCall)
}

func (fake *FakeStore) UpdateUserCalls(stub func(context.Context, db.UpdateUserParams) (db.User, error)) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = stub
}

func (fake *FakeStore) UpdateUserArgsForCall(i int) (context.Context, db.UpdateUserParams) {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	argsForCall := fake.updateUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) UpdateUserReturns(result1 db.User, result2 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	fake.updateUserReturns = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateUserReturnsOnCall(i int, result1 db.User, result2 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	if fake.updateUserReturnsOnCall == nil {
		fake.updateUserReturnsOnCall = make(map[int]struct {
			result1 db.User
			result2 error
		})
	}
	fake.updateUserReturnsOnCall[i] = struct {
		result1 db.User
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateVerifyEmail(arg1 context.Context, arg2 db.UpdateVerifyEmailParams) (db.VerifyEmail, error) {
	fake.updateVerifyEmailMutex.Lock()
	ret, specificReturn := fake.updateVerifyEmailReturnsOnCall[len(fake.updateVerifyEmailArgsForCall)]
	fake.updateVerifyEmailArgsForCall = append(fake.updateVerifyEmailArgsForCall, struct {
		arg1 context.Context
		arg2 db.UpdateVerifyEmailParams
	}{arg1, arg2})
	stub := fake.UpdateVerifyEmailStub
	fakeReturns := fake.updateVerifyEmailReturns
	fake.recordInvocation("UpdateVerifyEmail", []interface{}{arg1, arg2})
	fake.updateVerifyEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) UpdateVerifyEmailCallCount() int {
	fake.updateVerifyEmailMutex.RLock()
	defer fake.updateVerifyEmailMutex.RUnlock()
	return len(fake.updateVerifyEmailArgsForCall)
}

func (fake *FakeStore) UpdateVerifyEmailCalls(stub func(context.Context, db.UpdateVerifyEmailParams) (db.VerifyEmail, error)) {
	fake.updateVerifyEmailMutex.Lock()
	defer fake.updateVerifyEmailMutex.Unlock()
	fake.UpdateVerifyEmailStub = stub
}

func (fake *FakeStore) UpdateVerifyEmailArgsForCall(i int) (context.Context, db.UpdateVerifyEmailParams) {
	fake.updateVerifyEmailMutex.RLock()
	defer fake.updateVerifyEmailMutex.RUnlock()
	argsForCall := fake.updateVerifyEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) UpdateVerifyEmailReturns(result1 db.VerifyEmail, result2 error) {
	fake.updateVerifyEmailMutex.Lock()
	defer fake.updateVerifyEmailMutex.Unlock()
	fake.UpdateVerifyEmailStub = nil
	fake.updateVerifyEmailReturns = struct {
		result1 db.VerifyEmail
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateVerifyEmailReturnsOnCall(i int, result1 db.VerifyEmail, result2 error) {
	fake.updateVerifyEmailMutex.Lock()
	defer fake.updateVerifyEmailMutex.Unlock()
	fake.UpdateVerifyEmailStub = nil
	if fake.updateVerifyEmailReturnsOnCall == nil {
		fake.updateVerifyEmailReturnsOnCall = make(map[int]struct {
			result1 db.VerifyEmail
			result2 error
		})
	}
	fake.updateVerifyEmailReturnsOnCall[i] = struct {
		result1 db.VerifyEmail
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) VerifyEmailTx(arg1 context.Context, arg2 db.VerifyEmailTxParams) (db.VerifyEmailTxResult, error) {
	fake.verifyEmailTxMutex.Lock()
	ret, specificReturn := fake.verifyEmailTxReturnsOnCall[len(fake.verifyEmailTxArgsForCall)]
	fake.verifyEmailTxArgsForCall = append(fake.verifyEmailTxArgsForCall, struct {
		arg1 context.Context
		arg2 db.VerifyEmailTxParams
	}{arg1, arg2})
	stub := fake.VerifyEmailTxStub
	fakeReturns := fake.verifyEmailTxReturns
	fake.recordInvocation("VerifyEmailTx", []interface{}{arg1, arg2})
	fake.verifyEmailTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) VerifyEmailTxCallCount() int {
	fake.verifyEmailTxMutex.RLock()
	defer fake.verifyEmailTxMutex.RUnlock()
	return len(fake.verifyEmailTxArgsForCall)
}

func (fake *FakeStore) VerifyEmailTxCalls(stub func(context.Context, db.VerifyEmailTxParams) (db.VerifyEmailTxResult, error)) {
	fake.verifyEmailTxMutex.Lock()
	defer fake.verifyEmailTxMutex.Unlock()
	fake.VerifyEmailTxStub = stub
}

func (fake *FakeStore) VerifyEmailTxArgsForCall(i int) (context.Context, db.VerifyEmailTxParams) {
	fake.verifyEmailTxMutex.RLock()
	defer fake.verifyEmailTxMutex.RUnlock()
	argsForCall := fake.verifyEmailTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) VerifyEmailTxReturns(result1 db.VerifyEmailTxResult, result2 error) {
	fake.verifyEmailTxMutex.Lock()
	defer fake.verifyEmailTxMutex.Unlock()
	fake.VerifyEmailTxStub = nil
	fake.verifyEmailTxReturns = struct {
		result1 db.VerifyEmailTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) VerifyEmailTxReturnsOnCall(i int, result1 db.VerifyEmailTxResult, result2 error) {
	fake.verifyEmailTxMutex.Lock()
	defer fake.verifyEmailTxMutex.Unlock()
	fake.VerifyEmailTxStub = nil
	if fake.verifyEmailTxReturnsOnCall == nil {
		fake.verifyEmailTxReturnsOnCall = make(map[int]struct {
			result1 db.VerifyEmailTxResult
			result2 error
		})
	}
	fake.verifyEmailTxReturnsOnCall[i] = struct {
		result1 db.VerifyEmailTxResult
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addAccountBalanceMutex.RLock()
	defer fake.addAccountBalanceMutex.RUnlock()
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	fake.createTransferMutex.RLock()
	defer fake.createTransferMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.createUserTrxMutex.RLock()
	defer fake.createUserTrxMutex.RUnlock()
	fake.createVerifyEmailMutex.RLock()
	defer fake.createVerifyEmailMutex.RUnlock()
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	fake.getAccountForUpdateMutex.RLock()
	defer fake.getAccountForUpdateMutex.RUnlock()
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	fake.getTransferMutex.RLock()
	defer fake.getTransferMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.listAccountsMutex.RLock()
	defer fake.listAccountsMutex.RUnlock()
	fake.listEntriesMutex.RLock()
	defer fake.listEntriesMutex.RUnlock()
	fake.listTransfersMutex.RLock()
	defer fake.listTransfersMutex.RUnlock()
	fake.transferTrxMutex.RLock()
	defer fake.transferTrxMutex.RUnlock()
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	fake.updateVerifyEmailMutex.RLock()
	defer fake.updateVerifyEmailMutex.RUnlock()
	fake.verifyEmailTxMutex.RLock()
	defer fake.verifyEmailTxMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Store = new(FakeStore)
